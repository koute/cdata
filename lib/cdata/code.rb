# encoding: utf-8

#  Copyright (C) 2012  Jan Bujak <j+cdata@jabster.pl>
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program. If not, see <http://www.gnu.org/licenses/>.
#
#  As a special exception, you may create a larger work that contains part or
#  all of the C/C++ code generated by CData and distribute that work under
#  terms of your choice. If you modify this library, you may extend this
#  exception to your version of the library, but you are not obliged to do so.
#  If you do not wish to do so, delete this exception statement from your
#  version.

module CData

    class Serializer

        private

        def generate_header_start( fp )

            guard_id = "CDATA_#{fp.__id__.to_s.capitalize}_H"

            fp.m_puts <<-EOS

                /* This file was generated by cdata on #{Time.now}; DO NOT EDIT. */

                #ifndef #{guard_id}
                #define #{guard_id}

                #{@header_prologue.join( "\n" )}
                #include <string.h>

                #if __GNUC__ >= 4

                    #ifndef __llvm__
                        #pragma GCC diagnostic push
                        #pragma GCC diagnostic ignored "-Wignored-qualifiers"
                        #pragma GCC diagnostic ignored "-Wunused-but-set-parameter"
                    #endif
                    #pragma GCC visibility push( hidden )

                    #if __GNUC_MINOR__ >= 4
                        #pragma GCC push_options
                        /* #pragma GCC optimize ("-fmerge-all-constants") */
                    #endif

                #endif

                #ifdef CDATA_VERSION

                    #if CDATA_VERSION != #{VERSION}
                        #error "Files generated with two different cdata versions detected; cannot continue."
                    #endif

                #endif

                #ifndef CDATA_ONCE

                    #define CDATA_ONCE
                    #define CDATA_VERSION #{VERSION}

                    typedef struct _cdata_nil_t
                    {
                        operator int()
                        {
                            return 0;
                        }
                    } * cdata_nil_t;

                    /* Various hashes to be used for hashmaps; feel free to add your own overloads. */
                    inline unsigned cdata_hash( const char * const key, const unsigned length )
                    {
                        unsigned hash = 0;
                        for( unsigned i = 0; i < length; ++i )
                        {
                            hash += key[ i ];
                            hash += (hash << 10);
                            hash ^= (hash >> 6);
                        }
                        hash += (hash << 3);
                        hash ^= (hash >> 11);
                        hash += (hash << 15);

                        return hash;
                    }

                    inline unsigned cdata_hash( const char * const key )
                    {
                        return cdata_hash( key, strlen( key ) );
                    }

                    inline unsigned cdata_hash( unsigned key )
                    {
                        key = ( key + 0x7ed55d16 ) + ( key << 12 );
                        key = ( key ^ 0xc761c23c ) ^ ( key >> 19 );
                        key = ( key + 0x165667b1 ) + ( key <<  5 );
                        key = ( key + 0xd3a2646c ) ^ ( key <<  9 );
                        key = ( key + 0xfd7046c5 ) + ( key <<  3 );
                        key = ( key ^ 0xb55a4f09 ) ^ ( key >> 16 );
                        return key;
                    }

                    inline unsigned cdata_hash( float key )
                    {
                        union { float f; unsigned u; } s;
                        s.f = key;

                        return cdata_hash( s.u & 0xffffff00 );
                    }

                    inline unsigned cdata_hash( unsigned char key )
                    {
                        return cdata_hash( ( unsigned )key );
                    }

                    inline unsigned cdata_hash( unsigned short key )
                    {
                        return cdata_hash( ( unsigned )key );
                    }

                    inline unsigned cdata_hash( signed int key )
                    {
                        union { signed int s; unsigned u; } s;
                        s.s = key;

                        return cdata_hash( s.u );
                    }

                    inline unsigned cdata_hash( signed char key )
                    {
                        return cdata_hash( ( signed int )key );
                    }

                    inline unsigned cdata_hash( signed short key )
                    {
                        return cdata_hash( ( signed int )key );
                    }

                    inline unsigned cdata_hash( unsigned long long key )
                    {
                        return cdata_hash( ((unsigned)( (key >> 32) & 0xffffffff )) ^ ((unsigned)( key & 0xffffffff )) );
                    }

                    inline unsigned cdata_hash( signed long long key )
                    {
                        union { signed long long s; unsigned long long u; } s;
                        s.s = key;

                        return cdata_hash( s.u );
                    }

                    inline unsigned cdata_hash( bool key )
                    {
                        return cdata_hash( (unsigned)key );
                    }

                    inline unsigned cdata_hash( cdata_nil_t )
                    {
                        return 0;
                    }

                    /* Comparison functions used for hashes; feel free to add your own specializations. */
                    template < typename type_t >
                    inline bool cdata_compare( type_t a, type_t b )
                    {
                        return a == b;
                    }

                    template <>
                    inline bool cdata_compare< const char * >( const char * a, const char * b )
                    {
                        return !strcmp( a, b );
                    }

                    struct cdata_hash_index_t
                    {
                        unsigned bucket_key;
                        unsigned pair_key;

                        bool operator ==( const cdata_hash_index_t& another ) const
                        {
                            return bucket_key == another.bucket_key && pair_key == another.pair_key;
                        }

                        bool operator !=( const cdata_hash_index_t& another ) const
                        {
                            return operator ==( another ) == false;
                        }
                    };

                    /* A string with length meant to be used with data that has embedded zeros. */
                    struct cdata_string_t
                    {
                        const unsigned length;
                        const char * const value;

                        operator const char * () const
                        {
                            return ( const char * )value;
                        }
                    };

                    /*
                        A type class to allow cdata_generic_t fields;
                        as this is NOT meant to be a comprehensive RTTI system
                        the structure is empty.

                        Even when it is empty C++ guarantees that a variable
                        will have its own unique address - we can exploit this
                        to create type IDs for user created types.
                    */
                    struct cdata_type_t
                    {
                    };

                    /* This might seem ugly but I'd rather not have builtin static data. */
                    #define cdata_type_bool                 ( (const cdata_type_t * const)1 )
                    #define cdata_type_string               ( (const cdata_type_t * const)2 ) /* This is plain old const char string. */
                    #define cdata_type_string_with_length   ( (const cdata_type_t * const)3 ) /* This is cdata_string_t. */
                    #define cdata_type_unsigned_char        ( (const cdata_type_t * const)4 )
                    #define cdata_type_unsigned_short       ( (const cdata_type_t * const)5 )
                    #define cdata_type_unsigned_int         ( (const cdata_type_t * const)6 )
                    #define cdata_type_unsigned_long_long   ( (const cdata_type_t * const)7 )
                    #define cdata_type_signed_char          ( (const cdata_type_t * const)8 )
                    #define cdata_type_signed_short         ( (const cdata_type_t * const)9 )
                    #define cdata_type_signed_int           ( (const cdata_type_t * const)10 )
                    #define cdata_type_signed_long_long     ( (const cdata_type_t * const)11 )
                    #define cdata_type_float                ( (const cdata_type_t * const)12 )
                    #define cdata_type_generic              ( (const cdata_type_t * const)13 )

                    /* A generic container used with e.g. mixed type arrays. */
                    struct cdata_generic_t
                    {
                        const cdata_type_t * const type;
                        const void * const pointer;
                    };

                #endif

            EOS

        end

        def generate_header_end( fp )

            fp.m_puts <<-EOS

                #if __GNUC__ >= 4
                    #ifndef __llvm__
                        #pragma GCC diagnostic pop
                    #endif
                    #pragma GCC visibility pop

                    #if __GNUC_MINOR__ >= 4
                        #pragma GCC pop_options
                    #endif
                #endif

                #endif

            EOS

        end

        def generate_source_start( fp )

            fp.m_puts <<-EOS

                /* This file was generated by cdata on #{Time.now}; DO NOT EDIT. */

                #{@source_prologue.join( "\n" )}

                #if __GNUC__ >= 4
                    #pragma GCC visibility push( hidden )
                    #if __GNUC_MINOR__ >= 4
                        #pragma GCC push_options
                        /* #pragma GCC optimize ("-fmerge-all-constants") */
                    #endif
                #endif

            EOS

        end

        def generate_source_end( fp )

            fp.m_puts <<-EOS

                #if __GNUC__ >= 4
                    #pragma GCC visibility pop
                    #if __GNUC_MINOR__ >= 4
                        #pragma GCC pop_options
                    #endif
                #endif

            EOS

        end

        def generate_array_inline_code( fp, type )

            type_t  = type.native_name
            value_t = type.value_child.type.reference_name

            fp.m_puts <<-EOS

                const unsigned size;
                #{value_t} * const data;

                #{value_t} operator[]( const unsigned index ) const
                {
                    return data[ index ];
                }

                #{value_t} get( const unsigned index ) const
                {
                    return data[ index ];
                }

                class iterator
                {
                    const #{type_t}& m_array;
                    unsigned m_index;

                    public:

                        iterator( const #{type_t}& array, unsigned index ) : m_array( array ), m_index( index ) {}

                        bool operator !=( const iterator& another ) const
                        {
                            return another.m_index != m_index;
                        }

                        #{value_t} operator *() const
                        {
                            return m_array[ m_index ];
                        }

                        void operator ++()
                        {
                            m_index++;
                        }
                };

                iterator begin() const
                {
                    return iterator( *this, 0 );
                }

                iterator end() const
                {
                    return iterator( *this, size );
                }

                typedef iterator const_iterator;

            EOS

        end

        def generate_array_outside_code( fp, type )

            type_t = type.native_name
            fp.m_puts <<-EOS

                inline #{type_t} :: iterator begin( const #{type_t} * const array )
                {
                    return array->begin();
                }

                inline #{type_t} :: iterator end( const #{type_t} * const array )
                {
                    return array->end();
                }

            EOS

        end

        def generate_array_code( fp, type )

            fp.puts "struct #{type.native_name}"
            fp.puts "{"
            fp.extra_indentation += 4
            generate_array_inline_code( fp, type )
            fp.extra_indentation -= 4
            fp.puts "};"

            generate_array_outside_code( fp, type )

        end

        def generate_hash_inline_code( fp, type )

            type_t          = type.native_name
            pair_t          = "#{type_t}__pair_t"
            bucket_t        = "#{type_t}__bucket_t"
            key_t           = type.key_child.type.reference_name
            value_t         = type.value_child.type.reference_name
            mutable_key_t   = key_t.sub( / const\Z/, '' )
            mutable_value_t = value_t.sub( / const\Z/, '' )

            mutable_key_t.sub!( /\Aconst /, '' ) unless mutable_key_t.include?( "*" )
            mutable_value_t.sub!( /\Aconst /, '' ) unless mutable_value_t.include?( "*" )

            fp.m_puts <<-EOS

                const unsigned int first_bucket_index;
                const unsigned int size;
                const unsigned int table_size;
                const #{bucket_t} * const buckets;

                typedef #{key_t}            key_t;
                typedef #{value_t}          value_t;
                typedef #{pair_t}           pair_t;
                typedef #{mutable_key_t}    mutable_key_t;
                typedef #{mutable_value_t}  mutable_value_t;

                const value_t operator[]( const key_t& key ) const
                {
                    if( table_size == 0 ) return value_t();

                    unsigned hash = cdata_hash( key ) % table_size;
                    const #{bucket_t} * const bucket = &buckets[ hash ];

                    if( bucket->size == 0 ) return value_t();
                    if( bucket->size == 1 ) return bucket->pairs[ 0 ].value;

                    for( unsigned i = 0; i < bucket->size; ++i )
                        if( cdata_compare( bucket->pairs[ i ].key, key ) == true ) return bucket->pairs[ i ].value;

                    return value_t();
                }

                bool has_key( const key_t& key ) const
                {
                    if( table_size == 0 ) return false;

                    unsigned hash = cdata_hash( key ) % table_size;
                    const #{bucket_t} * const bucket = &buckets[ hash ];

                    if( bucket->size == 0 ) return false;
                    for( unsigned i = 0; i < bucket->size; ++i )
                        if( cdata_compare( bucket->pairs[ i ].key, key ) == true ) return true;

                    return false;
                }

                bool first( mutable_key_t& key, mutable_value_t& value, cdata_hash_index_t& index ) const
                {
                    index.bucket_key = first_bucket_index;
                    index.pair_key = 0;

                    if( index.bucket_key == (unsigned)~0 )
                        return false;

                    const #{bucket_t} * const bucket = &buckets[ first_bucket_index ];

                    key   = bucket->pairs[ 0 ].key;
                    value = bucket->pairs[ 0 ].value;

                    return true;
                }

                bool first( mutable_value_t& value, cdata_hash_index_t& index ) const
                {
                    index.bucket_key = first_bucket_index;
                    index.pair_key = 0;

                    if( index.bucket_key == (unsigned)~0 )
                        return false;

                    const #{bucket_t} * const bucket = &buckets[ first_bucket_index ];
                    value = bucket->pairs[ 0 ].value;

                    return true;
                }

                bool first( cdata_hash_index_t& index ) const
                {
                    index.bucket_key = first_bucket_index;
                    index.pair_key = 0;

                    if( index.bucket_key == (unsigned)~0 )
                        return false;

                    return true;
                }

                bool next( mutable_key_t& key, mutable_value_t& value, cdata_hash_index_t& index ) const
                {
                    if( next( index ) == false ) return false;

                    const #{bucket_t} * bucket = &buckets[ index.bucket_key ];
                    key   = bucket->pairs[ index.pair_key ].key;
                    value = bucket->pairs[ index.pair_key ].value;

                    return true;
                }

                bool next( mutable_value_t& value, cdata_hash_index_t& index ) const
                {
                    if( next( index ) == false ) return false;

                    const #{bucket_t} * bucket = &buckets[ index.bucket_key ];
                    value = bucket->pairs[ index.pair_key ].value;
                    return true;
                }

                bool next( cdata_hash_index_t& index ) const
                {
                    if( table_size == 0 ) return false;
                    if( index.bucket_key == (unsigned)~0 ) return false;

                    index.pair_key++;

                    const #{bucket_t} * bucket = &buckets[ index.bucket_key ];
                    if( index.pair_key >= bucket->size )
                    {
                        index.bucket_key = bucket->next_bucket_index;
                        index.pair_key = 0;

                        if( bucket->next_bucket_index == (unsigned)~0 )
                            return false;
                    }

                    return true;
                }

                bool get( mutable_key_t& key, mutable_value_t& value, const cdata_hash_index_t& index ) const
                {
                    if( index.bucket_key == (unsigned)~0 ) return false;

                    const #{bucket_t} * bucket = &buckets[ index.bucket_key ];
                    key   = bucket->pairs[ index.pair_key ].key;
                    value = bucket->pairs[ index.pair_key ].value;
                    return true;
                }

                bool get( mutable_value_t& value, const cdata_hash_index_t& index ) const
                {
                    if( index.bucket_key == (unsigned)~0 ) return false;

                    const #{bucket_t} * bucket = &buckets[ index.bucket_key ];
                    value = bucket->pairs[ index.pair_key ].value;
                    return true;
                }

                class iterator
                {
                    const #{type_t}& m_hash;
                    cdata_hash_index_t m_index;

                    public:

                        iterator( const #{type_t}& hash, cdata_hash_index_t index ) : m_hash( hash ), m_index( index ) {}

                        bool operator !=( const iterator& another ) const
                        {
                            return another.m_index != m_index;
                        }

                        const pair_t * operator *() const
                        {
                            if( m_index.bucket_key == (unsigned)~0 ) return 0;

                            const #{bucket_t} * bucket = &m_hash.buckets[ m_index.bucket_key ];
                            return &bucket->pairs[ m_index.pair_key ];
                        }

                        void operator ++()
                        {
                            m_hash.next( m_index );
                        }
                };

                iterator begin() const
                {
                    cdata_hash_index_t index;
                    first( index );

                    return iterator( *this, index );
                }

                iterator end() const
                {
                    cdata_hash_index_t index;
                    index.bucket_key = (unsigned)~0;
                    index.pair_key = 0;

                    return iterator( *this, index );
                }

                typedef iterator const_iterator;

            EOS

        end

        def generate_hash_outside_code( fp, type )

            type_t          = type.native_name
            pair_t          = "#{type_t}__pair_t"
            bucket_t        = "#{type_t}__bucket_t"
            key_t           = type.key_child.type.reference_name
            value_t         = type.value_child.type.reference_name
            mutable_key_t   = key_t.sub( / const\Z/, '' )
            mutable_value_t = value_t.sub( / const\Z/, '' )

            mutable_key_t.sub!( /\Aconst /, '' ) unless mutable_key_t.include?( "*" )
            mutable_value_t.sub!( /\Aconst /, '' ) unless mutable_value_t.include?( "*" )

            fp.m_puts <<-EOS

                struct #{pair_t}
                {
                    #{key_t} key;
                    #{value_t} value;
                };

                struct #{bucket_t}
                {
                    const unsigned int size;
                    const unsigned int next_bucket_index;
                    const #{pair_t} * const pairs;
                };

            EOS

        end

        def generate_hash_code( fp, type )

            generate_hash_outside_code( fp, type )

            fp.puts "struct #{type.native_name}"
            fp.puts "{"
            fp.extra_indentation += 4
            generate_hash_inline_code( fp, type )
            fp.extra_indentation -= 4
            fp.puts "};"

            type_t = type.native_name
            fp.m_puts <<-EOS

                inline #{type_t} :: iterator begin( const #{type_t} * const hash )
                {
                    return hash->begin();
                }

                inline #{type_t} :: iterator end( const #{type_t} * const hash )
                {
                    return hash->end();
                }

            EOS

        end

    end

end
